# Multiple-alias syntax for foreach

## Preamble

    Author:
    Sponsor: Nicholas Clark <nick@ccl4.org>
    ID:      0001
    Status:  Draft

## Abstract

Implement the currently illegal syntax `for my ($key, $value) (%hash) { ... }` to act as two-at-a-time iteration over hashes. This approach is not specific to hashes - it generalises to n-at-a-time over any list.

## Motivation

The `each` function is generally discouraged due to implementation details, but is still the most "pretty" and concise way to write such a loop:

    while (my ($key, $value) = each %hash) { ... }

An alternative to this would be a syntax to alias multiple items per iteration in a `for` loop.

    for my ($key, $value) (%hash) { ... }

This generalizes as a "bundler" - to alias a number of elements from the list equal to the number of variables specified. Such as:

    for my ($foo, $bar, $baz) (@array) {
        # $foo, $bar, and $baz are the next three elements of @array,
        # or undef if overflowed

## Rationale

The existing syntax to iterate over the keys and values of a hash:

    while (my ($key, $value) = each %hash) { ... }

suffers from several problems

* For correctness it assumes that the internal state of the hash being "clean" - to be robust one should reset the iterator first with `keys %hash;` in void context
* It's hard to teach to beginners - to understand what is going on here one needs to know
  - list assignment
  - empty lists are false; non-empty lists are true
  - that the hash holds an internal iterator
* You can't modify the hash inside the loop without confusing the iterator

The proposed syntax solves all of these.

## Specification

## Backwards Compatibility

## Security Implications

## Examples

*FIXME* - are there useful examples that aren't in the Motivation?

## Prototype Implementation

"Here's one I made earlier" applies - we already have one written, so there's no need to duplicate work

## Rejected Ideas

### Permit `undef` in the list of scalars

    for my ($a, undef, $c) (1 .. 9) { ... }

It's a reasonable generalisation of list assignment, where you can assign to undef to mean "ignore this value". I can see that this **might** be useful.  It's also safe syntax to implement (although I didn't try, and I'm not sure how hard it would be).

But it adds considerable runtime complexity. The easiest implementation is if there are exactly *n* scalars, all declared in the `for` loop itself, because this way they occupy adjacent Pad slots. This means that there is only one extra integer to store in the optree, which used both to calculate the *n*-at-a-time **and** the addresses of the target variables.

Adding `undef` to the mix rules out a simple, clear implementation.

### Permit @array or %hash in the list of lexicals

    for my ($key, $value, %rest) (%hash) { ... }
    for my ($first, $second, @rest) (@array) {... }

Syntactically these all "work", and don't violate the assumption that all lexicals are in adjacent Pad slots. But it would add complexity to the runtime. Generalising *1 scalar at a time* to *n at a time* is mostly just adding a C `for` loop around some existing (known working) code.

Implementing these would mean adding code for what is basically a funky way of writing

    { my ($key, $value, %rest) = %hash; ... }
    { my ($first, $second, @rest) = @array; ... }

### Permit `our` as well as `my`

Using `our` instead of `my` works in the grammar. ie we can parse this:

    for our ($foo, $bar, $baz) (@array) {

However, the implementation would be far more complex. Each package variable
would need a pair of GV and RV2GV ops to set it up for aliasing in a lexical,
meaning that we'd need to create a list to feed into ENTERITER, and have it
process that list to set up Pads. This complexity isn't worth it.

### Alternative parsable syntaxes suggested by Father Chrysostomos

When this syntax was suggested in 2017, Father Chrysostomos observed that in addition to the first syntax, the next two are also currently errors and could be parsed:

    for my ($key, $value) (%hash) { ... }
    for my $key, my $value (%hash) { ... }
    for $foo, $bar (%hash) { ... }

He notes that it's only this illegal syntax that could not be parsed:

    for ($foo, $bar) (%hash) { ... } # syntax error

https://www.nntp.perl.org/group/perl.perl5.porters/2017/04/msg243856.html

Strictly we also can't parse this:

    for (my $key, my $value) (%hash) { ... }

meaning that we can't offer choice of syntax in `for` analogous to:

    (my $foo, my $bar, my $baz) = @ARGV
    my ($foo, $bar, $baz) = @ARGV

which parse to the same optree.

However, these two lines are **not the same**:

    my $key, my $value = @pair;
    my ($key, $value) = @pair;

hence we should not offer the alternative syntax:

    for my $key, my $value (%hash) { ... }

For implementation reasons we only want to handle lexicals. This rules out:

    for $foo, $bar (%hash) { ... }

So these alternative possible syntaxes should not be offered.

## Open Issues

## Copyright

Copyright (C) 2021, Nicholas Clark

This document and code and documentation within it may be used, redistributed and/or modified under the same terms as Perl itself.
